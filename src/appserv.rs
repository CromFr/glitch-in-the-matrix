//! Facilities for creating a Matrix Application Service (AS).
//!
//! # On tokens and authentication
//!
//! An AS has two types of token that it needs to worry about:
//!
//! - the `as_token`, the token the **AS** will give to the **HS**;
//! - the `hs_token`, the token the **HS** will give to the **AS**.
//!
//! Don't get confused! The `hs_token` should be provided when instantiating an
//! `AsServer` in this module (so that it can verify the authenticity of the HS'
//! requests), while the `as_token` is useful for constructing `MatrixClient`s
//! with AS superpowers.
//!
//! # On `hyper`
//!
//! This server is built on the latest version of `hyper`, 0.11. This makes it
//! able to be asynchronous (yay!), but it also means that this server is utter
//! crap in terms of efficiency. See the rant situated in the docs for
//! `AsServer::run` for more.
use hyper::server::{Http, Request, Response, Service};
use hyper::header::ContentLength;
use hyper::{self, Method, StatusCode, Uri};
use futures;
use futures::*;
use types::*;
use std::error::Error;
use std::net::SocketAddr;
use errors::MatrixResult;
use std::marker::PhantomData;
use std::sync::{Arc, Mutex};
use url;
use serde_json;

const EMPTY_OBJECT: &str = "{}";

type HyperServiceFuture = Box<Future<Item = Response, Error = hyper::Error>>;
/// Error response type for requests made to an application service.
///
/// This implements `From<E>`, so errors you throw normally will be converted
/// to `InternalServerError(E)`.
pub enum AsError<E> {
    /// The resource requested was not found, or is inaccessible.
    ///
    /// Results in a HTTP 404 response to the HS.
    NotFound,
    /// An internal server error occurred.
    ///
    /// Results in a HTTP 500 response to the HS, including the error's
    /// description.
    InternalServerError(E)
}
impl<E> From<E> for AsError<E> {
    fn from(err: E) -> Self {
        AsError::InternalServerError(err)
    }
}
/// A `Future` with an `AsError` error type. Returned from all
/// `ApplicationService` implementations.
pub type AsFuture<E> = Box<Future<Item = (), Error = AsError<E>>>;
/// A handler for an Application Service (AS).
pub trait ApplicationService: Send {
    /// The user-defined error type involved in the `AsFuture`s.
    type Error: Error;
    /// Process a request for a given room alias.
    ///
    /// This endpoint is invoked by the homeserver on an application service to
    /// query the existence of a given room alias. The homeserver will only
    /// query room aliases inside the application service's aliases namespace.
    /// The homeserver will send this request when it receives a request to join
    /// a room alias within the application service's namespace.
    fn get_room(&mut self, rid: &str) -> AsFuture<Self::Error>;
    /// Process a request for a given user.
    ///
    /// This endpoint is invoked by the homeserver on an application service to
    /// query the existence of a given user ID. The homeserver will only query
    /// user IDs inside the application service's users namespace. The
    /// homeserver will send this request when it receives an event for an
    /// unknown user ID in the application service's namespace.
    fn get_user(&mut self, uid: &str) -> AsFuture<Self::Error>;
    /// This API is called when the HS wants to push an event (or batch of
    /// events) to the AS.
    ///
    /// The `txid` provided is a unique value generated by the HS used to ensure
    /// idempotency of requests. The `AsServer` will ensure that it never calls
    /// this method more than once with different `txid`s by storing a `Vec` of
    /// used `txid`s internally.
    fn push_transactions(&mut self, txid: String, events: Events) -> AsFuture<Self::Error>;
}
struct AsServerInner<H> {
    txids: Vec<String>,
    handler: H
}
/// An HTTP server that handles application service requests, dispatching them
/// to a specified `ApplicationService` implementation.
///
/// # Type parameters
///
/// - `H`: the `ApplicationService` implementation to use
/// - `E`: the `Error` associated type of the `ApplicationService`
pub struct AsServer<H, E> {
    inner: Arc<Mutex<AsServerInner<H>>>,
    token: String,
    _ph: PhantomData<E>
}
impl<H, E> AsServer<H, E>
    where E: Error + 'static,
          H: ApplicationService<Error = E> + 'static {
    /// Make a new `AsServer` from a specified handler and `hs_token`.
    ///
    /// Confused about tokens? See "On tokens and authentication" in the
    /// module-level documentation.
    ///
    /// To actually make use of the server, you probably want to call `run()` on
    /// it.
    pub fn new(hs_token: String, hdl: H) -> Self {
        let inner = AsServerInner {
            txids: vec![],
            handler: hdl,
        };
        Self {
            inner: Arc::new(Mutex::new(inner)),
            token: hs_token,
            _ph: PhantomData
        }
    }
    /// Run the server indefinitely on the given `addr`, blocking the whole
    /// thread.
    ///
    /// # It's rant time
    ///
    /// This server is built on the latest version of `hyper`, 0.11. This makes
    /// it able to be asynchronous (yay!), but it also means that this server is
    /// utter crap in terms of efficiency, because the `hyper` API *makes*
    /// implementors *clone their server for every incoming connection*.
    ///
    /// I honestly *do not understand* how in the nine hells this thing is
    /// supposed to work. PRs are very welcome from anyone who is able to
    /// understand it...
    ///
    /// At least the `AsServer` is `Send` so you can execute this on another
    /// thread...
    pub fn run(&self, addr: SocketAddr) -> MatrixResult<()> {
        let http = Http::new();
        let inner = self.inner.clone();
        let token = self.token.clone();
        //                            \/ WTF?
        let serv = http.bind(&addr, move || Ok(Self { inner: inner.clone(), token: token.clone(), _ph: PhantomData }))?;
        serv.run()?;
        Ok(())
    }
    fn bad_req(brr: BadRequestReply) -> Response {
        let val = serde_json::to_string(&brr).unwrap();
        Response::new()
            .with_header(ContentLength(val.len() as u64))
            .with_status(StatusCode::InternalServerError)
            .with_body(val)
    }
    fn empty_resp() -> Response {
        Response::new()
            .with_header(ContentLength(EMPTY_OBJECT.len() as u64))
            .with_status(StatusCode::Ok)
            .with_body(EMPTY_OBJECT)
    }
    fn fut_to_hyper(fut: AsFuture<E>) -> HyperServiceFuture {
        Box::new(fut.then(|res| {
            let resp = match res {
                Ok(()) => Self::empty_resp(),
                Err(e) => {
                    match e {
                        AsError::NotFound => Response::new()
                            .with_status(StatusCode::NotFound),
                        AsError::InternalServerError(e) => {
                            let val = BadRequestReply {
                                errcode: "M_UNKNOWN".to_string(),
                                error: e.to_string()
                            };
                            Self::bad_req(val)
                        },
                    }
                }
            };
            futures::future::ok(resp)
        }))
    }
    fn get_room(&self, path: Vec<String>) -> HyperServiceFuture {
        let mut inner = self.inner.lock().unwrap();
        let rid = path.into_iter().nth(2).unwrap();
        Self::fut_to_hyper(inner.handler.get_room(&rid))
    }
    fn get_user(&self, path: Vec<String>) -> HyperServiceFuture {
        let mut inner = self.inner.lock().unwrap();
        let uid = path.into_iter().nth(2).unwrap();
        Self::fut_to_hyper(inner.handler.get_user(&uid))
    }
    fn push_transactions(&self, req: Request, path: Vec<String>) -> HyperServiceFuture {
        let txid = path.into_iter().nth(2).unwrap();
        {
            let mut inner = self.inner.lock().unwrap();
            if inner.txids.contains(&txid) {
                return futures::future::ok(Self::empty_resp()).boxed();
            }
            inner.txids.push(txid.clone());
        }
        let inner = self.inner.clone();
        Box::new(req.body().concat2().and_then(move |rqb| {
            if let Ok(e) = serde_json::from_slice::<Events>(&rqb) {
                let mut inner = inner.lock().unwrap();
                Self::fut_to_hyper(inner.handler.push_transactions(txid, e))
            }
            else {
                let val = BadRequestReply {
                    errcode: "M_UNKNOWN".to_string(),
                    error: "Invalid JSON payload".to_string()
                };
                futures::future::ok(Self::bad_req(val)).boxed()
            }
        }))
    }
    fn is_valid_token(&self, url: &Uri) -> bool {
        for (k, v) in url::form_urlencoded::parse(url.query().unwrap_or("").as_bytes()) {
            if k == "access_token" && v == self.token {
                return true;
            }
        }
        false
    }
}
impl<H, E> Service for AsServer<H, E>
    where E: Error + 'static,
          H: ApplicationService<Error = E> + 'static {
    type Request = Request;
    type Response = Response;
    type Error = hyper::Error;
    type Future = HyperServiceFuture;

    fn call(&self, req: Request) -> Self::Future {
        if !self.is_valid_token(&req.uri()) {
            let val = BadRequestReply {
                errcode: "M_FORBIDDEN".to_string(),
                error: "AS token invalid or not supplied".to_string()
            };
            let val = serde_json::to_string(&val).unwrap();
            return futures::future::ok(
                Response::new()
                    .with_header(ContentLength(val.len() as u64))
                    .with_status(StatusCode::Forbidden)
                    .with_body(val)
            ).boxed();
        }
        let path = req.path().split("/").map(|x| x.to_string()).collect::<Vec<_>>();
        if path.len() > 2 {
            match (req.method(), &path[1] as &str) {
                (&Method::Get, "rooms") => return self.get_room(path),
                (&Method::Put, "transactions") => return self.push_transactions(req, path),
                (&Method::Get, "users") => return self.get_user(path),
                _ => {}
            }
        }
        futures::future::ok(
            Response::new()
                .with_status(StatusCode::BadRequest)
        ).boxed()
    }
}
